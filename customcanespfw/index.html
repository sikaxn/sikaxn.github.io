<!DOCTYPE html>
<html>
  <head>
    <title>Flash Firmware - ESP Web Tools</title>
    <script type="module" src="https://unpkg.com/esp-web-tools@10.1.1/dist/web/install-button.js?module"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>


    <style>
      #status-msg {
        margin: 8px 0;
        font-weight: bold;
        color: darkred;
      }
    </style>
  </head>
  <body>
    <h1>Flash Firmware</h1>

    <label for="firmware-type">Select Firmware:</label>
    <select id="firmware-type" disabled>
      <option>Loading firmware list...</option>
    </select>
    <div id="status-msg"></div>

    <br /><br />

    <div id="addressable-group" style="display:none;">
      <label for="can-id">Select CAN ID:</label>
      <select id="can-id">
        <!-- Options injected dynamically -->
      </select>
    </div>

    <br /><br />

    <div style="color: darkred; font-weight: bold;">
      Please hold <code>IO0</code> button while clicking flash (after selecting serial port and connecting).<br>
      Please close Arduino IDE if you can't open serial port!
    </div>

    <br />

    <esp-web-install-button id="flash-button">
      <span slot="unsupported">Your browser does not support Web Serial. Try Chrome or Edge.</span>
    </esp-web-install-button>
    
    <br><br><br>
    <a href="webIDTool.html" target="_blank">
       WEB CAN Device Number set tool
    </a>

    <br /><br />
    <hr />
<footer id="release-notes" style="font-size: 0.9em; color: gray;">
  <div>Loading release notes…</div>
</footer>


<script>
  const firmwareType = document.getElementById("firmware-type");
  const canIdSelect = document.getElementById("can-id");
  const addressableGroup = document.getElementById("addressable-group");
  const button = document.getElementById("flash-button");
  const statusMsg = document.getElementById("status-msg");

  // Markdown containers (for per-firmware notes)
  const mdUpContainer = document.createElement("div");
  const mdDownContainer = document.createElement("div");
  button.parentNode.insertBefore(mdUpContainer, button);
  button.parentNode.insertBefore(mdDownContainer, button.nextSibling);

  let firmwareDefs = [];

  function setStatus(msg, color = "darkred") {
    statusMsg.textContent = msg || "";
    statusMsg.style.color = color;
  }

  function setCanIdOptions(canIds) {
    if (Array.isArray(canIds) && canIds.length) {
      canIdSelect.innerHTML = canIds
        .map(id => `<option value="${id}">CAN ID ${id}</option>`)
        .join("");
    } else {
      const fallback = Array.from({ length: 8 }, (_, i) => i + 1);
      canIdSelect.innerHTML = fallback
        .map(id => `<option value="${id}">CAN ID ${id}</option>`)
        .join("");
    }
  }

  function computeManifest(def) {
    if (def.manifest) return def.manifest;
    if (def.manifestTemplate) {
      const canId = canIdSelect.value;
      return def.manifestTemplate.replace("{CAN_ID}", canId);
    }
    return "";
  }

  async function renderMarkdown(url, container) {
    container.innerHTML = "";
    if (!url) return;
    try {
      const resp = await fetch(url, { cache: "no-cache" });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const text = await resp.text();
      // marked is a global from the earlier script import
      container.innerHTML = marked.parse(text);
    } catch (err) {
      container.innerHTML = `<div style="color:red;">⚠️ Failed to load ${url}: ${err.message}</div>`;
    }
  }

  async function updateUI() {
    const type = firmwareType.value;
    const def = firmwareDefs.find(f => f.id === type);
    if (!def) return;

    if (def.needsCanId || (def.manifestTemplate && def.manifestTemplate.includes("{CAN_ID}"))) {
      addressableGroup.style.display = "block";
    } else {
      addressableGroup.style.display = "none";
    }

    const manifest = computeManifest(def);
    if (manifest) {
      button.setAttribute("manifest", manifest);
      setStatus("");
    } else {
      button.removeAttribute("manifest");
      setStatus("No manifest found for this firmware.");
    }

    // Markdown rendering for firmware entry
    await renderMarkdown(def.markdown_up, mdUpContainer);
    await renderMarkdown(def.markdown_down, mdDownContainer);
  }

  async function init() {
    try {
      const resp = await fetch("firmwarelist.json", { cache: "no-cache" });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const data = await resp.json();
      firmwareDefs = data.firmwares || [];
      if (!firmwareDefs.length) throw new Error("Firmware list is empty");

      firmwareType.innerHTML = firmwareDefs
        .map(f => `<option value="${f.id}">${f.label}</option>`)
        .join("");
      firmwareType.disabled = false;

      if (firmwareDefs[0]?.canIds) setCanIdOptions(firmwareDefs[0].canIds);
      else setCanIdOptions();

      firmwareType.addEventListener("change", async () => {
        const def = firmwareDefs.find(f => f.id === firmwareType.value);
        if (def?.canIds) setCanIdOptions(def.canIds);
        await updateUI();
      });
      canIdSelect.addEventListener("change", updateUI);

      await updateUI();
    } catch (err) {
      setStatus("⚠️ Failed to load firmwarelist.json: " + err.message);
    }
  }

  // --- Load release notes from releasenotes.md ---
  async function loadReleaseNotes() {
    const footer = document.getElementById("release-notes");
    if (!footer) return;
    try {
      const resp = await fetch("releasenotes.md", { cache: "no-cache" });
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      const text = await resp.text();
      footer.innerHTML = marked.parse(text);
    } catch (err) {
      footer.innerHTML = `<div style="color:red;">⚠️ Failed to load releasenotes.md: ${err.message}</div>`;
    }
  }

  init();
  loadReleaseNotes();
</script>


  </body>
</html>
